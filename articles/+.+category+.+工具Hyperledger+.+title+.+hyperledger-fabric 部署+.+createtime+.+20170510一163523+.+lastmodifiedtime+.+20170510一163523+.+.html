

<html><head><meta charset="UTF-8"><title>hyperledger-fabric 部署
</title><meta name="viewport" content="width=device-width, initial-scala=1.0"></head><body><div id="markdown">






<h1 id="hyperledger-fabric-">hyperledger-fabric 部署</h1>
<p><a href="http://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html#prerequisites-and-setup">hyperledger_getting_start</a></p>
<hr>
<h2 id="hello-world">Hello World</h2>
<ol>
<li><p>执行自动初始环境的脚本, bootstrap.sh自动完成以下工作: 下载yaml配置, 下载cryptogen和configtxgen, 下载Fabric的docker镜像.</p>
<pre><code class="lang-bash">mkdir fabric-sample
cd fabric-sample
curl -sS https://raw.githubusercontent.com/hyperledger/fabric/master/examples/e2e_cli/bootstrap.sh | bash
</code></pre>
</li>
<li><p>执行network_setup.sh脚本, network_setup.sh脚本自动完成以下工作: 调用generateArtifacts.sh去执行cryptogen和configtxgen工具, 然后调用script.sh来启动网络, 将节点加入信道, 驱动事务.</p>
<pre><code class="lang-bash">cd release/linux-amd64/
sudo ./network_setup.sh up
</code></pre>
<p>注意虚拟机内存调到2g</p>
<p>成功后提示: All GOOD, End-2-End execution completed</p>
</li>
<li><p>查看节点之间的通信命令</p>
<pre><code class="lang-bash">sudo docker ps
</code></pre>
</li>
<li><p>查看事务日志</p>
<pre><code class="lang-bash">sudo docker logs -f cli
</code></pre>
</li>
<li><p>查看智能合约日志</p>
<pre><code class="lang-bash">sudo docker logs dev-peer0.org1.example.com-mycc-1.0
sudo docker logs dev-peer0.org2.example.com-mycc-1.0
sudo docker logs dev-peer1.org2.example.com-mycc-1.0
</code></pre>
</li>
<li><p>清理</p>
<pre><code class="lang-bash">sudo ./network_setup.sh down
</code></pre>
</li>
</ol>
<hr>
<h2 id="-">详细说明</h2>
<ol>
<li><p>crypto生成器</p>
<p>crypto-config.yaml定义了网络拓扑结构, crypto能够生成一个认证库, 提供给组织和组织下的单位. 每个组织提供一个唯一的根认证, 根认证绑定了组织下的单位节点. 事务被一个节点的私有键(keystore)加密, 然后被公有键(sigcerts)解密. crypto-config.yaml中的count变量指定组织下有多少单位, 例子中组织下有2个单位.</p>
<p>执行后生成的认证将被放在crypto-config目录中.</p>
</li>
<li><p>configtxgen工具</p>
<p>configtxgen被用来创建4个构件(artifacts):</p>
<ol>
<li><p>orderer bootstrap block</p>
<p>作为ordering服务的根块</p>
</li>
<li><p>fabric channel configuration transaction</p>
<p>信道(channel)事务(transaction)文件在信道创建时通过广播发送到orderer.</p>
</li>
<li><p>anchor peer transaction(每个组织各一个, 共2个)</p>
<p>两个锚(anchor)节点(peer)指明信道上每个组织的锚节点.</p>
</li>
</ol>
<p>configtx.yaml定义了网络, 包含3个成员, 一个Ordered组织(OrdererOrg)和两个Peer组织(Org1和Org2), 每个Peer组织包含两个节点(peer node). 同时指定了一个联营企业(consortium): SampleConsortium, 它包含两个Peer组织. 注意Profiles配置, 有两个唯一的头, 一个定义orderer根块: TwoOrgsOrdererGenesis, 另一个定义信道: TwoOrgsChannel, 这些头很关键, 将被用作参数来创建构件(artifacts).</p>
<p>configtx.yaml同时包含两个扩展说明. 首先给每个Peer组织(Org)(peer0.org1.example.com和peer0.org2.example.com)指定了锚节点(anchor peer), 然后指向每个成员的MSP目录位置, 反过来存储orderer根块下的每个组织的根认证, 这是个决定性的概念. 现在任何与orderer服务通信的网络节点拥有了自己的数字认证.</p>
<p>简便起见, generateArtifacts.sh被用于生成crypto数据和4个配置构件, 将生成的数据放在channel-artifacts目录下.</p>
</li>
<li><p>执行cryptogen, 生成认证</p>
<pre><code class="lang-bash">./bin/cryptogen generate --config=./crypto-config.yaml
</code></pre>
<p>忽略警告: Before using BCCSP, please call InitFactories(). Falling back to bootBCCSP.</p>
</li>
<li><p>执行configtxgen, 生成orderer根块</p>
<pre><code class="lang-bash">FABRIC_CFG_PATH=$PWD ./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
</code></pre>
</li>
<li><p>执行configtxgen, 创建信道(channel)事务(transaction)构件(artifact)</p>
<pre><code class="lang-bash">FABRIC_CFG_PATH=$PWD ./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel
</code></pre>
</li>
<li><p>执行configtxgen, 定义Org1的锚(anchor)节点(peer)</p>
<pre><code class="lang-bash">FABRIC_CFG_PATH=$PWD ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP
</code></pre>
</li>
<li><p>执行configtxgen, 定义Org2的锚(anchor)节点(peer)</p>
<pre><code class="lang-bash">FABRIC_CFG_PATH=$PWD ./bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP
</code></pre>
</li>
<li><p>启动网络</p>
</li>
</ol>
<p>docker-compose-cli.yaml定义了docker集群配置, 注释掉CLI集合下的command配置, 后续手动执行各操作.</p>
<pre><code class="lang-yaml">working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
# command: /bin/bash -c &#39;./scripts/script.sh ${CHANNEL_NAME}; sleep $TIMEOUT&#39;
volumes:
......
</code></pre>
<p>执行docker-compose, -d参数让程序作为daemon守护进程, 不要占用控制台</p>
<pre><code class="lang-bash">sudo CHCHANNEL_NAME=mychannel TIMEOUT=300 docker-compose -f ./docker-compose-cli.yaml up -d
</code></pre>


</div>
<script src="../js/jquery-1.12.3.min.js" charset="utf-8"></script>
<link rel="stylesheet" href="../css/highlight.min.css">
<script src="../js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
jQuery(function ($) {
});
</script></body></html>

