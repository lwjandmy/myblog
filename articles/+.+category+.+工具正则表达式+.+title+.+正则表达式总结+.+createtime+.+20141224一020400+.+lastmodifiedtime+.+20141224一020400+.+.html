

<html><head><meta charset="UTF-8"><title>正则表达式总结
</title><meta name="viewport" content="width=device-width, initial-scala=1.0"></head><body><div id="markdown">






<h1 id="-">正则表达式总结</h1>
<p>基本例子</p>
<pre><code class="lang-text">[0-9]{1} 匹配1个数字，其中[0-9]可以用\d替换，即\d{1}。再BRE(Basic Regular Expression)中，大括号要加转意字符，即\d\{1\}
</code></pre>
<p>常用转意字符</p>
<pre><code class="lang-text">\b   不匹配内容，但决定匹配起始位置，起始位置为单词的开头（单词前面非字母）
\d   [0-9]
\D   [^0-9]
\w   [A-Z0-9]
\W   [^A-Z0-9]
\s   [\t\n\r\f]   (BRE,ERE不支持)
\S   [^\t\n\r\f]   (BRE,ERE不支持)
d - digital, w - word, s - space
t - tab, n - newline, r - return, f - whitespace

^匹配行首
$匹配行尾

.* 匹配任意字符，.匹配除\n之外任何字符,*匹配任意个.字符
</code></pre>
<p>BRE(Basic regexp),ERE(Extern regexp),PRE(perl regexp)区别</p>
<p><a href="http://www.cnblogs.com/wangkangluo1/archive/2012/04/13/2446021.html">正则表达式分类 区别</a></p>
<p>最大匹配和最小匹配</p>
<pre><code class="lang-text">在数量模糊的匹配中，比如.*，*意味着数量是任意的。
在字符串1a2a中，
(.*)a，会匹配a前任意字符，
最大匹配时，匹配1a2，即一直向后匹配，让匹配的内容最大。由于匹配时无需判断字符与a是否相等，只需判断字符是否符合.*，所以效率高。
最小匹配时，匹配1，即先判断字符和a的关系，不相等再匹配，让匹配的内容最小。由于匹配时同时判断.*和a，所以效率与低。
默认是最大匹配，高效率。
</code></pre>
<p>用最大匹配实现最小匹配功能</p>
<pre><code class="lang-text">要想实现，就要在模糊匹配中不使用.*，而是使用[^a]*a这种形式。
对匹配的截止的设置，如果是单个字符，即遇到单个字符就结束匹配，可以用这种形式[^a]*a。
但若需要遇到字符串才结束匹配，则需要环视。
</code></pre>


</div>
<script src="../js/jquery-1.12.3.min.js" charset="utf-8"></script>
<link rel="stylesheet" href="../css/highlight.min.css">
<script src="../js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
jQuery(function ($) {
});
</script></body></html>

