

<html><head><meta charset="UTF-8"><title>正则表达式两种引擎 NFA引擎的匹配原理 匹配优先和忽略优先
</title><meta name="viewport" content="width=device-width, initial-scala=1.0"></head><body><div id="markdown">






<h1 id="-nfa-">正则表达式两种引擎 NFA引擎的匹配原理 匹配优先和忽略优先</h1>
<p>两种引擎：</p>
<ul>
<li>NFA, 传统的引擎, 表达式主导</li>
<li>DFA, 较新的引擎, 内容主导</li>
</ul>
<p>两种引擎区别：</p>
<p>例：用&#39;AA(11|22|33)&#39;匹配&#39;AA22&#39;</p>
<pre><code class="lang-text">    NFA: 表达式主导，由正则表达式中&#39;AA&#39;, 匹配内容中的&#39;AA&#39;, 
    接着是表达式的&#39;(11|22|33)&#39;, 先用表达式的&#39;11&#39;尝试匹配内容的&#39;22&#39;, 并将&#39;(11|22|33)&#39;中&#39;22&#39;和&#39;33&#39;保存起来，当匹配失败时继续尝试匹配&#39;22&#39;和&#39;33&#39;
    此时用&#39;11&#39;匹配&#39;22&#39;失败，于是再用保存的&#39;22&#39;匹配&#39;22&#39;, 此时匹配成功，引擎结束.

    DFA: 内容主导，由内容的&#39;AA&#39;，匹配正则表达式的&#39;AA&#39;,
    接着用内容的’22‘的第一个&#39;2&#39;匹配表达式的&#39;(11|22|33)&#39;, 发现只有表达式的&#39;22&#39;的第一个‘2’能匹配
    再接着用内容&#39;22&#39;的第二个‘2’，匹配表达式‘22’的第二个‘2’，发现也能匹配，于是匹配成功，引擎结束。

    总结：两种引擎结果相同。DFA更快，因为表达式中的内容不会多次尝试匹配。但NFA引擎更值得研究，用的更广。
</code></pre>
<p>NFA引擎的匹配原理：</p>
<pre><code class="lang-text">例：匹配优先和忽略优先: 用‘AB？C’匹配‘AC&#39;
    首先由表达式的‘A’匹配内容的‘A’
    接着是表达式&#39;B?&#39;，由于‘？’是匹配优先量词(‘？？’是忽略优先量词)，所以优先尝试用‘B存在’匹配‘C’，并将‘B不存在&#39;保存进来, 当匹配失败时继续尝试‘B不存在’
    此时匹配失败，回溯到‘B不存在’，B不存在，则用表达式的‘C’匹配内容的‘C’，匹配成功。
例：匹配优先和忽略优先: 用&#39;.*BC&#39;匹配&#39;ABC&#39;
    首先是‘.*&#39;，由于‘＊’是匹配优先量词（‘＊？’是忽略优先量词），所以用‘.*&#39;优先匹配所有字符&#39;ABC&#39;, 
        并将&#39;.*&#39;匹配0个字符的情况保存起来，
        &#39;.*&#39;匹配1个字符&#39;A&#39;的情况保存起来，
        &#39;.*&#39;匹配2个字符&#39;AB&#39;的情况保存起来，
    然后用表达式的’BC‘匹配内容的空字符，发现无法匹配，于是回溯一步，到&#39;.*&#39;匹配2个字符&#39;AB&#39;的情况，
    此时用表达式的&#39;BC&#39;匹配内容的‘C’,还是无法匹配，于是再回流一步，到&#39;.*&#39;匹配1个字符&#39;A&#39;的情况，
    此时用表达式的‘BC&#39;匹配内容的&#39;BC&#39;, 匹配成功.
</code></pre>


</div>
<script src="../js/jquery-1.12.3.min.js" charset="utf-8"></script>
<link rel="stylesheet" href="../css/highlight.min.css">
<script src="../js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
jQuery(function ($) {
});
</script></body></html>

