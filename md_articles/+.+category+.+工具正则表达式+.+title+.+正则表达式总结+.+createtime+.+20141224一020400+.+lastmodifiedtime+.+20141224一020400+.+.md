# 正则表达式总结

基本例子

```text
[0-9]{1} 匹配1个数字，其中[0-9]可以用\d替换，即\d{1}。再BRE(Basic Regular Expression)中，大括号要加转意字符，即\d\{1\}
```



常用转意字符

```text
\b   不匹配内容，但决定匹配起始位置，起始位置为单词的开头（单词前面非字母）
\d   [0-9]
\D   [^0-9]
\w   [A-Z0-9]
\W   [^A-Z0-9]
\s   [\t\n\r\f]   (BRE,ERE不支持)
\S   [^\t\n\r\f]   (BRE,ERE不支持)
d - digital, w - word, s - space
t - tab, n - newline, r - return, f - whitespace

^匹配行首
$匹配行尾

.* 匹配任意字符，.匹配除\n之外任何字符,*匹配任意个.字符
```



BRE(Basic regexp),ERE(Extern regexp),PRE(perl regexp)区别

[正则表达式分类 区别](http://www.cnblogs.com/wangkangluo1/archive/2012/04/13/2446021.html)


最大匹配和最小匹配

```text
在数量模糊的匹配中，比如.*，*意味着数量是任意的。
在字符串1a2a中，
(.*)a，会匹配a前任意字符，
最大匹配时，匹配1a2，即一直向后匹配，让匹配的内容最大。由于匹配时无需判断字符与a是否相等，只需判断字符是否符合.*，所以效率高。
最小匹配时，匹配1，即先判断字符和a的关系，不相等再匹配，让匹配的内容最小。由于匹配时同时判断.*和a，所以效率与低。
默认是最大匹配，高效率。
```


用最大匹配实现最小匹配功能

```text
要想实现，就要在模糊匹配中不使用.*，而是使用[^a]*a这种形式。
对匹配的截止的设置，如果是单个字符，即遇到单个字符就结束匹配，可以用这种形式[^a]*a。
但若需要遇到字符串才结束匹配，则需要环视。
```


